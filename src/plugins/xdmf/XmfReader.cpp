//=============================================================================
// This software developed by Stellar Science Ltd Co and the U.S. Government.
// Copyright (C) 2009 Stellar Science. Government-purpose rights granted.
//-----------------------------------------------------------------------------
#include <xdmf/XmfReader.hpp>

#include <xdmf/impl/TreeBuilder.hpp>

// This file is generated by the build.
#include <XdmfRng.hpp>

#include <xdm/Item.hpp>
#include <xdm/RefPtr.hpp>
#include <xdm/StaticAssert.hpp>

#include <libxml/parser.h>
#include <libxml/relaxng.h>
#include <libxml/tree.h>

#include <sstream>

#include <cstdarg>

XDMF_NAMESPACE_BEGIN

namespace {

// RNG Schema content
char const * const kXdmfRngSchema = XDMF_RNG_SCHEMA;
const unsigned int kXdmfRngSchemaLength = XDMF_RNG_SCHEMA_LENGTH;

// Callback class to throw an exception upon validation errors.
void validationErrorCallback( void * context, const char * msg, ... ) {
  va_list ap;
  std::string newmessage;
  newmessage.resize( 512 );
  va_start(ap, msg);
  vsnprintf(&newmessage[0], 512, msg, ap);
  va_end(ap);
  XDM_THROW( xdmFormat::ReadError( newmessage ) );
}

// Validate an XDMF document.
bool validate( xmlDocPtr document ) {
  xmlRelaxNGParserCtxtPtr context;
  xmlRelaxNGPtr schemaDoc;
  xmlRelaxNGValidCtxtPtr validation;
  bool result = false;
  try {
    context = xmlRelaxNGNewMemParserCtxt( 
      kXdmfRngSchema, 
      kXdmfRngSchemaLength );
    if (!context) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }
          
    schemaDoc = xmlRelaxNGParse( context );
    if (!schemaDoc) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    validation = xmlRelaxNGNewValidCtxt( schemaDoc );
    if (!validation) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    int validationResult = xmlRelaxNGValidateDoc( validation, document );
    if ( validationResult == 0 ) {
      result = true;
    } else if ( validationResult > 0 ) {
      result = false;
    } else {
      throw xdmFormat::ReadError( "Error: Internal validation error." );
    }
  } catch ( ... ) {
    if (context) xmlRelaxNGFreeParserCtxt(context);
    if (schemaDoc) xmlRelaxNGFree(schemaDoc);
    if (validation) xmlRelaxNGFreeValidCtxt(validation);
    throw;
  }
  if (context) xmlRelaxNGFreeParserCtxt(context);
  if (schemaDoc) xmlRelaxNGFree(schemaDoc);
  if (validation) xmlRelaxNGFreeValidCtxt(validation);
  return result;
}

//------------------------------------------------------------------------------
// Tree Construction
//------------------------------------------------------------------------------

// Build an XDM tree given a parsed and validated XDMF document.
xdm::RefPtr< xdm::Item > buildTree( xmlDocPtr document ) {
  return xdm::RefPtr< xdm::Item >();
}

} // namespace anon

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
class XmfReader::Private {
public:
  xmlDocPtr mDocument;

  Private() :
    mDocument() {
  }

  ~Private() {
  }
};

XmfReader::XmfReader() : 
  xdmFormat::Reader(),
  mImp( new Private ) {
}

XmfReader::~XmfReader() {
}

xdm::RefPtr< xdm::Item > 
XmfReader::readItem( const xdm::FileSystemPath& path ) {
  // Check the file exists.
  if ( !exists( path ) ) {
    XDM_THROW( xdmFormat::ReadError( "Requested path does not exist." ) );
  }
  
  // Parse the document into a tree that can be traversed.
  mImp->mDocument = xmlParseFile( path.pathString().c_str() );
  if ( !mImp->mDocument ) {
    XDM_THROW( xdmFormat::ReadError( "Unable to parse XDMF document." ) );
  }

  if ( !validate( mImp->mDocument ) ) {
    XDM_THROW( xdmFormat::ReadError( "Invalid XDMF document." ) );
  }

  // Build the tree given the root node of the validated document as input.
  impl::TreeBuilder builder( mImp->mDocument );
  return builder.buildTree();
}

bool XmfReader::update( 
  xdm::RefPtr< xdm::Item > item,
  const xdm::FileSystemPath& path,
  std::size_t timeStep ) {
  return false;
}

XDMF_NAMESPACE_END

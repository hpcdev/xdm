//=============================================================================
// This software developed by Stellar Science Ltd Co and the U.S. Government.
// Copyright (C) 2009 Stellar Science. Government-purpose rights granted.
//-----------------------------------------------------------------------------
#include <xdmf/XmfReader.hpp>

#include <xdmf/impl/TreeBuilder.hpp>
#include <xdmf/impl/XPathQuery.hpp>

// This file is generated by the build.
#include <XdmfRng.hpp>

#include <xdm/Item.hpp>
#include <xdm/ItemVisitor.hpp>
#include <xdm/RefPtr.hpp>
#include <xdm/StaticAssert.hpp>
#include <xdm/UniformDataItem.hpp>

#include <libxml/parser.h>
#include <libxml/relaxng.h>
#include <libxml/tree.h>

#include <sstream>

#include <cstdarg>

XDMF_NAMESPACE_BEGIN

namespace {

// RNG Schema content
char const * const kXdmfRngSchema = XDMF_RNG_SCHEMA;
const unsigned int kXdmfRngSchemaLength = XDMF_RNG_SCHEMA_LENGTH;

// Callback function to throw an exception with informative information upon
// a validation error.
void structuredValidationErrorCallback( void* userData, xmlErrorPtr error ) {
  ValidationError exception(
    error->file,
    error->line,
    error->int2,
    error->message );
  XDM_THROW( exception );
}

// Validate an XDMF document.
bool validate( xmlDocPtr document ) {
  xmlRelaxNGParserCtxtPtr context;
  xmlRelaxNGPtr schemaDoc;
  xmlRelaxNGValidCtxtPtr validation;
  bool result = false;
  try {
    context = xmlRelaxNGNewMemParserCtxt( 
      kXdmfRngSchema, 
      kXdmfRngSchemaLength );
    if (!context) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }
          
    schemaDoc = xmlRelaxNGParse( context );
    if (!schemaDoc) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    validation = xmlRelaxNGNewValidCtxt( schemaDoc );
    if (!validation) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    // Set the validation error callback function to handle invalid documents
    xmlRelaxNGSetValidStructuredErrors(
      validation,
      &structuredValidationErrorCallback,
      0 );

    int validationResult = xmlRelaxNGValidateDoc( validation, document );
    if ( validationResult == 0 ) {
      result = true;
    } else if ( validationResult > 0 ) {
      result = false;
    } else {
      throw xdmFormat::ReadError( "Error: Internal validation error." );
    }
  } catch ( ... ) {
    if (context) xmlRelaxNGFreeParserCtxt(context);
    if (schemaDoc) xmlRelaxNGFree(schemaDoc);
    if (validation) xmlRelaxNGFreeValidCtxt(validation);
    throw;
  }
  if (context) xmlRelaxNGFreeParserCtxt(context);
  if (schemaDoc) xmlRelaxNGFree(schemaDoc);
  if (validation) xmlRelaxNGFreeValidCtxt(validation);
  return result;
}

// Read an XML document at the specified path.
xmlDoc * readDocument( const xdm::FileSystemPath& path ) {
  // Check the file exists.
  if ( !exists( path ) ) {
    XDM_THROW( xdmFormat::ReadError( "Requested path does not exist." ) );
  }

  xmlDoc * document = 0;
  // Parse the document into a tree that can be traversed.
  document = xmlParseFile( path.pathString().c_str() );
  if ( !document ) {
    XDM_THROW( xdmFormat::ReadError( "Unable to parse XDMF document." ) );
  }

  if ( !validate( document ) ) {
    XDM_THROW( xdmFormat::ReadError( "Invalid XDMF document." ) );
  }
  return document;
}

// Visitor that knows how to update items for a new timestep.
class UpdateXdmfTreeVisitor : public xdm::ItemVisitor {
public:
  UpdateXdmfTreeVisitor( xmlDocPtr document, xmlNode * node ) :
    mDocument( document ),
    mNode( node ),
    mNewData( false ) {
  }

  virtual ~UpdateXdmfTreeVisitor() {
  }

  virtual void apply( xdm::UniformDataItem& item ) {
    try {
      typedef impl::InputItem< xdm::UniformDataItem > InputUDI;
      InputUDI& inputItem = dynamic_cast< InputUDI& >( item );
      // Find the corresponding node in the new node context.
      impl::XPathQuery nodeQuery( mDocument, mNode, inputItem.xpathExpr() );
      if ( nodeQuery.size() > 0 ) {
        impl::TreeBuilder builder( mNode );
        builder.configureUniformDataItem( inputItem, nodeQuery.node( 0 ) );
        mNewData = true;
      }
    } catch ( const std::bad_cast& ) {
      // we don't know how to update this item, leave it alone.
    }
  }

  bool newData() const { return mNewData; }

private:
  xmlDoc * mDocument;
  xmlNode * mNode;
  bool mNewData;
};

} // namespace

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
class XmfReader::Private {
public:
  xmlDocPtr mDocument;
  std::vector< xmlNode * > mTimestepNodes;
  xdm::FileSystemPath mInitialFilePath;

  Private() :
    mDocument(),
    mTimestepNodes(),
    mInitialFilePath() {
  }

  ~Private() {
  }
};

XmfReader::XmfReader() : 
  xdmFormat::Reader(),
  mImp( new Private ) {
}

XmfReader::~XmfReader() {
}

xdm::RefPtr< xdm::Item > 
XmfReader::readItem( const xdm::FileSystemPath& path ) {
  static const char * kTemporalCollectionExpr =
    "/Xdmf/Grid[@GridType=\"Collection\" and @CollectionType=\"Temporal\"]";

  xdm::RefPtr< xdm::Item > result;

  // Read the document.
  mImp->mDocument = readDocument( path );
  xmlNode * rootNode = xmlDocGetRootElement( mImp->mDocument );

  // Determine if the XDMF document contains a single time step or a temporal
  // collection.
  impl::XPathQuery temporalCollectionQuery(
    mImp->mDocument,
    rootNode,
    kTemporalCollectionExpr );

  if ( temporalCollectionQuery.size() > 0 ) {
    // The XDMF file contains a temporal collection.
    xmlNode * temporalCollectionRoot = temporalCollectionQuery.node( 0 );
    impl::XPathQuery stepGridQuery( mImp->mDocument, temporalCollectionRoot, "Grid" );
    if ( stepGridQuery.size() == 0 ) {
      XDM_THROW( xdmFormat::ReadError(
        "XDMF Temporal collection contains no time steps" ) );
    }
    // Set the XML node for each time step.
    for ( size_t i = 0; i < temporalCollectionQuery.size(); ++i ) {
      mImp->mTimestepNodes.push_back( temporalCollectionQuery.node( i ) );
    }
    // Build the tree using the first grid as the structure prototype.
    impl::TreeBuilder builder( stepGridQuery.node( 0 ) );
    result = builder.buildTree();
  } else {
    // The file does not contain a temporal collection. Search the Domain
    // element for Grid children.
    impl::XPathQuery gridQuery( mImp->mDocument, rootNode, "/Xdmf/Domain/Grid" );
    if ( gridQuery.size() != 0 ) {
      // FIXME handle multiple grids in a single Domain.
      impl::TreeBuilder builder( gridQuery.node( 0 ) );
      result = builder.buildTree();
    }
  }
  return result;
}

bool XmfReader::update( 
  xdm::RefPtr< xdm::Item > item,
  const xdm::FileSystemPath& path,
  std::size_t timeStep )
{
  if ( mImp->mTimestepNodes.size() < timeStep ) {
    return false;
  }

  // Get the XML node corresponding to the requested time step.
  xmlNode * stepNode = mImp->mTimestepNodes[timeStep];

  UpdateXdmfTreeVisitor v( mImp->mDocument, stepNode );
  item->accept( v );
  return v.newData();
}

XDMF_NAMESPACE_END

//=============================================================================
// This software developed by Stellar Science Ltd Co and the U.S. Government.
// Copyright (C) 2009 Stellar Science. Government-purpose rights granted.
//-----------------------------------------------------------------------------
#include <xdmf/XmfReader.hpp>

#include <xdmf/impl/TreeBuilder.hpp>

// This file is generated by the build.
#include <XdmfRng.hpp>

#include <xdm/Item.hpp>
#include <xdm/ItemVisitor.hpp>
#include <xdm/RefPtr.hpp>
#include <xdm/StaticAssert.hpp>

#include <libxml/parser.h>
#include <libxml/relaxng.h>
#include <libxml/tree.h>

#include <sstream>

#include <cstdarg>

XDMF_NAMESPACE_BEGIN

namespace {

// RNG Schema content
char const * const kXdmfRngSchema = XDMF_RNG_SCHEMA;
const unsigned int kXdmfRngSchemaLength = XDMF_RNG_SCHEMA_LENGTH;

// Callback function to throw an exception with informative information upon
// a validation error.
void structuredValidationErrorCallback( void* userData, xmlErrorPtr error ) {
  ValidationError exception(
    error->file,
    error->line,
    error->int2,
    error->message );
  XDM_THROW( exception );
}

// Validate an XDMF document.
bool validate( xmlDocPtr document ) {
  xmlRelaxNGParserCtxtPtr context;
  xmlRelaxNGPtr schemaDoc;
  xmlRelaxNGValidCtxtPtr validation;
  bool result = false;
  try {
    context = xmlRelaxNGNewMemParserCtxt( 
      kXdmfRngSchema, 
      kXdmfRngSchemaLength );
    if (!context) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }
          
    schemaDoc = xmlRelaxNGParse( context );
    if (!schemaDoc) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    validation = xmlRelaxNGNewValidCtxt( schemaDoc );
    if (!validation) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    // Set the validation error callback function to handle invalid documents
    xmlRelaxNGSetValidStructuredErrors(
      validation,
      &structuredValidationErrorCallback,
      0 );

    int validationResult = xmlRelaxNGValidateDoc( validation, document );
    if ( validationResult == 0 ) {
      result = true;
    } else if ( validationResult > 0 ) {
      result = false;
    } else {
      throw xdmFormat::ReadError( "Error: Internal validation error." );
    }
  } catch ( ... ) {
    if (context) xmlRelaxNGFreeParserCtxt(context);
    if (schemaDoc) xmlRelaxNGFree(schemaDoc);
    if (validation) xmlRelaxNGFreeValidCtxt(validation);
    throw;
  }
  if (context) xmlRelaxNGFreeParserCtxt(context);
  if (schemaDoc) xmlRelaxNGFree(schemaDoc);
  if (validation) xmlRelaxNGFreeValidCtxt(validation);
  return result;
}

class UpdateXdmfTreeVisitor : public xdm::ItemVisitor {
public:
  UpdateXdmfTreeVisitor( xmlDocPtr document, xmlNode * node ) : mNode( node ) {
    mXPathContext = xmlXPathNewContext( document );
  }
  virtual ~UpdateXdmfTreeVisitor() {
    xmlXPathFreeContext( mXPathContext );
  }

  virtual void apply( xdm::UniformDataItem& item ) {
  }

private:
  xmlNode * mNode;
  xmlXPathContextPtr mXPathContext;
};

} // namespace

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
class XmfReader::Private {
public:
  xmlDocPtr mDocument;
  std::vector< xmlNode * > mTimestepNodes;

  Private() :
    mDocument(),
    mTimestepNodes() {
  }

  ~Private() {
  }
};

XmfReader::XmfReader() : 
  xdmFormat::Reader(),
  mImp( new Private ) {
}

XmfReader::~XmfReader() {
}

xdm::RefPtr< xdm::Item > 
XmfReader::readItem( const xdm::FileSystemPath& path ) {
  // Check the file exists.
  if ( !exists( path ) ) {
    XDM_THROW( xdmFormat::ReadError( "Requested path does not exist." ) );
  }
  
  // Parse the document into a tree that can be traversed.
  mImp->mDocument = xmlParseFile( path.pathString().c_str() );
  if ( !mImp->mDocument ) {
    XDM_THROW( xdmFormat::ReadError( "Unable to parse XDMF document." ) );
  }

  if ( !validate( mImp->mDocument ) ) {
    XDM_THROW( xdmFormat::ReadError( "Invalid XDMF document." ) );
  }

  // Build the tree given the root node of the validated document as input.
  impl::TreeBuilder builder( mImp->mDocument );

  xdm::RefPtr< xdm::Item > result = builder.buildTree();
  mImp->mTimestepNodes = builder.timestepNodes();
  return result;
}

bool XmfReader::update( 
  xdm::RefPtr< xdm::Item > item,
  const xdm::FileSystemPath& path,
  std::size_t timeStep ) {
  if ( mImp->mTimestepNodes.size() < timeStep ) {
    return false;
  }

  // Get the XML node corresponding to the requested time step.
  xmlNode * stepNode = mImp->mTimestepNodes[timeStep];
}

XDMF_NAMESPACE_END

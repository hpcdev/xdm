//=============================================================================
// This software developed by Stellar Science Ltd Co and the U.S. Government.
// Copyright (C) 2009 Stellar Science. Government-purpose rights granted.
//-----------------------------------------------------------------------------
#include <xdmf/XmfReader.hpp>

#include <xdmf/impl/TreeBuilder.hpp>
#include <xdmf/impl/XPathQuery.hpp>

// This file is generated by the build.
#include <XdmfRng.hpp>

#include <xdm/Item.hpp>
#include <xdm/ItemVisitor.hpp>
#include <xdm/RefPtr.hpp>
#include <xdm/StaticAssert.hpp>
#include <xdm/UniformDataItem.hpp>
#include <xdm/UpdateVisitor.hpp>

#include <libxml/parser.h>
#include <libxml/relaxng.h>
#include <libxml/tree.h>

#include <sstream>

#include <cstdarg>

XDMF_NAMESPACE_BEGIN

namespace {

// RNG Schema content
char const * const kXdmfRngSchema = XDMF_RNG_SCHEMA;
const unsigned int kXdmfRngSchemaLength = XDMF_RNG_SCHEMA_LENGTH;

// Callback function to throw an exception with informative information upon
// a validation error.
void structuredValidationErrorCallback( void* userData, xmlErrorPtr error ) {
  xdmFormat::FileReadError exception(
    error->file,
    error->line,
    error->int2,
    error->message );
  XDM_THROW( exception );
}

// Validate an XDMF document.
bool validate( xmlDocPtr document ) {
  xmlRelaxNGParserCtxtPtr context;
  xmlRelaxNGPtr schemaDoc;
  xmlRelaxNGValidCtxtPtr validation;
  bool result = false;
  try {
    context = xmlRelaxNGNewMemParserCtxt( 
      kXdmfRngSchema, 
      kXdmfRngSchemaLength );
    if (!context) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }
          
    schemaDoc = xmlRelaxNGParse( context );
    if (!schemaDoc) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    validation = xmlRelaxNGNewValidCtxt( schemaDoc );
    if (!validation) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    // Set the validation error callback function to handle invalid documents
    xmlRelaxNGSetValidStructuredErrors(
      validation,
      &structuredValidationErrorCallback,
      0 );

    int validationResult = xmlRelaxNGValidateDoc( validation, document );
    if ( validationResult == 0 ) {
      result = true;
    } else if ( validationResult > 0 ) {
      result = false;
    } else {
      throw xdmFormat::ReadError( "Error: Internal validation error." );
    }
  } catch ( ... ) {
    if (context) xmlRelaxNGFreeParserCtxt(context);
    if (schemaDoc) xmlRelaxNGFree(schemaDoc);
    if (validation) xmlRelaxNGFreeValidCtxt(validation);
    throw;
  }
  if (context) xmlRelaxNGFreeParserCtxt(context);
  if (schemaDoc) xmlRelaxNGFree(schemaDoc);
  if (validation) xmlRelaxNGFreeValidCtxt(validation);
  return result;
}

// Read an XML document at the specified path.
xmlDoc * readDocument( const xdm::FileSystemPath& path ) {
  // Check the file exists.
  if ( !exists( path ) ) {
    XDM_THROW( xdmFormat::ReadError( "Requested path does not exist." ) );
  }

  xmlDoc * document = 0;
  // Parse the document into a tree that can be traversed.
  document = xmlParseFile( path.pathString().c_str() );
  if ( !document ) {
    XDM_THROW( xdmFormat::ReadError( "Unable to parse XDMF document." ) );
  }

  if ( !validate( document ) ) {
    XDM_THROW( xdmFormat::ReadError( "Invalid XDMF document." ) );
  }
  return document;
}

// A ref counted std vector of xmlNodes.
class SharedNodeVector :
  public xdm::ReferencedObject,
  private std::vector< xmlNode * >
{
  typedef std::vector< xmlNode * > VectorBase;
public:
  SharedNodeVector() : VectorBase() {}
  virtual ~SharedNodeVector() {}

  using VectorBase::push_back;
  using VectorBase::operator[];
  using VectorBase::size;
};

// A ref counted RAII class for an XML document.
class XmlDocumentManager : public xdm::ReferencedObject {
public:
  XmlDocumentManager( xmlDoc * document ) : mDocument( document ) {}
  virtual ~XmlDocumentManager() {
    xmlFreeDoc( mDocument );
  }
  xmlDoc * get() { return mDocument; }
private:
  xmlDoc * mDocument;
};

// Update callback for an impl::InputItem< UniformDataItem >.
class InputUDIUpdateCallback :
  public xdm::ItemUpdateCallback< impl::InputItem< xdm::UniformDataItem > >
{
public:
  InputUDIUpdateCallback(
    xdm::RefPtr< XmlDocumentManager > document,
    xdm::RefPtr< SharedNodeVector > nodes ) :
    mDocument( document ),
    mNodeVector( nodes ) {}
  virtual ~InputUDIUpdateCallback() {}

  virtual void update(
    impl::InputItem< xdm::UniformDataItem >& item,
    size_t seriesIndex )
  {
    if ( seriesIndex >= mNodeVector->size() ) {
      XDM_THROW( xdmFormat::ReadError( "Time step out of bounds" ) );
    }
    xmlNode * stepNode = (*mNodeVector)[seriesIndex];
    std::string expr = item.xpathExpr();
    impl::XPathQuery itemQuery( mDocument->get(), stepNode, expr );
    if ( itemQuery.size() != 0 ) {
      impl::TreeBuilder build( stepNode );
      build.configureUniformDataItem( item, itemQuery.node( 0 ) );
    }
  }
private:
  xdm::RefPtr< XmlDocumentManager > mDocument;
  xdm::RefPtr< SharedNodeVector > mNodeVector;
};

// Visitor to attach update callbacks to the items in the tree.
class AttachCallbacks : public xdm::ItemVisitor {
public:
  xdm::RefPtr< XmlDocumentManager > mDocument;
  xdm::RefPtr< SharedNodeVector > mNodeVector;
  virtual void apply( xdm::UniformDataItem& item ) {
    typedef impl::InputItem< xdm::UniformDataItem > InputUDI;
    try {
      InputUDI& input = dynamic_cast< InputUDI& >( item );
      item.setUpdateCallback( xdm::makeRefPtr(
        new InputUDIUpdateCallback( mDocument, mNodeVector ) ) );
    } catch ( const std::bad_cast& ) {
      // do nothing
    }
  }
};

} // namespace

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
class XmfReader::Private {
public:
};

XmfReader::XmfReader() : 
  xdmFormat::Reader(),
  mImp( new Private ) {
}

XmfReader::~XmfReader() {
}

xdmFormat::Reader::ReadResult
XmfReader::readItem( const xdm::FileSystemPath& path ) {
  static const char * kTemporalCollectionExpr =
    "/Xdmf/Domain/Grid[@GridType=\"Collection\" and @CollectionType=\"Temporal\"]";

  xdm::RefPtr< xdm::Item > result;

  // Read the document.
  xdm::RefPtr< XmlDocumentManager > doc(
    new XmlDocumentManager( readDocument( path ) ) );
  xmlNode * rootNode = xmlDocGetRootElement( doc->get() );

  // Determine if the XDMF document contains a single time step or a temporal
  // collection.
  impl::XPathQuery temporalCollectionQuery(
   doc->get(),
    rootNode,
    kTemporalCollectionExpr );

  xdm::RefPtr< SharedNodeVector > timestepNodes( new SharedNodeVector );
  if ( temporalCollectionQuery.size() > 0 ) {
    // The XDMF file contains a temporal collection.
    xmlNode * temporalCollectionRoot = temporalCollectionQuery.node( 0 );
    impl::XPathQuery stepGridQuery( doc->get(), temporalCollectionRoot, "Grid" );
    if ( stepGridQuery.size() == 0 ) {
      XDM_THROW( xdmFormat::ReadError(
        "XDMF Temporal collection contains no time steps" ) );
    }
    // Set the XML node for each time step.
    for ( size_t i = 0; i < temporalCollectionQuery.size(); ++i ) {
      timestepNodes->push_back( temporalCollectionQuery.node( i ) );
    }
    // Build the tree using the first grid as the structure prototype.
    impl::TreeBuilder builder( stepGridQuery.node( 0 ) );
    result = builder.buildTree();
  } else {
    // The file does not contain a temporal collection. Search the Domain
    // element for Grid children.
    impl::XPathQuery gridQuery( doc->get(), rootNode, "/Xdmf/Domain/Grid" );
    if ( gridQuery.size() != 0 ) {
      // FIXME handle multiple grids in a single Domain.
      xmlNode * gridNode = gridQuery.node( 0 );
      impl::TreeBuilder builder( gridNode );
      result = builder.buildTree();
      timestepNodes->push_back( gridNode );
    }
  }

  // Attach update callbacks to allow series-varying behavior.
  AttachCallbacks visitor;
  visitor.mDocument = doc;
  visitor.mNodeVector = timestepNodes;
  result->accept( visitor );

  return xdmFormat::Reader::ReadResult( result, timestepNodes->size() );
}

bool XmfReader::update( 
  xdm::RefPtr< xdm::Item > item,
  const xdm::FileSystemPath& path,
  std::size_t timeStep )
{
  try {
    xdm::UpdateVisitor update( timeStep );
    item->accept( update );
    return true;
  } catch ( const xdmFormat::ReadError& ) {
    return false;
  }
}

XDMF_NAMESPACE_END

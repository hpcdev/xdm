//=============================================================================
// This software developed by Stellar Science Ltd Co and the U.S. Government.
// Copyright (C) 2009 Stellar Science. Government-purpose rights granted.
//-----------------------------------------------------------------------------
#include <xdmf/XmfReader.hpp>

#include <xdmf/impl/TreeBuilder.hpp>
#include <xdmf/impl/XPathQuery.hpp>

// This file is generated by the build.
#include <XdmfRng.hpp>

#include <xdm/Item.hpp>
#include <xdm/ItemVisitor.hpp>
#include <xdm/RefPtr.hpp>
#include <xdm/StaticAssert.hpp>
#include <xdm/UniformDataItem.hpp>

#include <libxml/parser.h>
#include <libxml/relaxng.h>
#include <libxml/tree.h>

#include <sstream>

#include <cstdarg>

XDMF_NAMESPACE_BEGIN

namespace {

// RNG Schema content
char const * const kXdmfRngSchema = XDMF_RNG_SCHEMA;
const unsigned int kXdmfRngSchemaLength = XDMF_RNG_SCHEMA_LENGTH;

// Callback function to throw an exception with informative information upon
// a validation error.
void structuredValidationErrorCallback( void* userData, xmlErrorPtr error ) {
  ValidationError exception(
    error->file,
    error->line,
    error->int2,
    error->message );
  XDM_THROW( exception );
}

// Validate an XDMF document.
bool validate( xmlDocPtr document ) {
  xmlRelaxNGParserCtxtPtr context;
  xmlRelaxNGPtr schemaDoc;
  xmlRelaxNGValidCtxtPtr validation;
  bool result = false;
  try {
    context = xmlRelaxNGNewMemParserCtxt( 
      kXdmfRngSchema, 
      kXdmfRngSchemaLength );
    if (!context) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }
          
    schemaDoc = xmlRelaxNGParse( context );
    if (!schemaDoc) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    validation = xmlRelaxNGNewValidCtxt( schemaDoc );
    if (!validation) {
      throw xdmFormat::ReadError( "Error: unable to parse schema." );
    }

    // Set the validation error callback function to handle invalid documents
    xmlRelaxNGSetValidStructuredErrors(
      validation,
      &structuredValidationErrorCallback,
      0 );

    int validationResult = xmlRelaxNGValidateDoc( validation, document );
    if ( validationResult == 0 ) {
      result = true;
    } else if ( validationResult > 0 ) {
      result = false;
    } else {
      throw xdmFormat::ReadError( "Error: Internal validation error." );
    }
  } catch ( ... ) {
    if (context) xmlRelaxNGFreeParserCtxt(context);
    if (schemaDoc) xmlRelaxNGFree(schemaDoc);
    if (validation) xmlRelaxNGFreeValidCtxt(validation);
    throw;
  }
  if (context) xmlRelaxNGFreeParserCtxt(context);
  if (schemaDoc) xmlRelaxNGFree(schemaDoc);
  if (validation) xmlRelaxNGFreeValidCtxt(validation);
  return result;
}

class UpdateXdmfTreeVisitor : public xdm::ItemVisitor {
public:
  UpdateXdmfTreeVisitor( xmlDocPtr document, xmlNode * node ) :
    mDocument( document ),
    mNode( node ),
    mNewData( false ) {
    mXPathContext = xmlXPathNewContext( mDocument );
  }

  virtual ~UpdateXdmfTreeVisitor() {
    xmlXPathFreeContext( mXPathContext );
  }

  virtual void apply( xdm::UniformDataItem& item ) {
    try {
      typedef impl::InputItem< xdm::UniformDataItem > InputUDI;
      InputUDI& inputItem = dynamic_cast< InputUDI& >( item );
      // Find the corresponding node in the new node context.
      impl::XPathQuery nodeQuery( mXPathContext, mNode, inputItem.xpathExpr() );
      if ( nodeQuery.size() > 0 ) {
        impl::TreeBuilder builder( mDocument );
        builder.configureUniformDataItem( inputItem, nodeQuery.node( 0 ) );
        mNewData = true;
      }
    } catch ( const std::bad_cast& ) {
      // we don't know how to update this item, leave it alone.
    }
  }

  bool newData() const { return mNewData; }

private:
  xmlDoc * mDocument;
  xmlNode * mNode;
  xmlXPathContext * mXPathContext;
  bool mNewData;
};

} // namespace

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
class XmfReader::Private {
public:
  xmlDocPtr mDocument;
  std::vector< xmlNode * > mTimestepNodes;
  xdm::FileSystemPath mInitialFilePath;

  Private() :
    mDocument(),
    mTimestepNodes(),
    mInitialFilePath() {
  }

  ~Private() {
  }
};

XmfReader::XmfReader() : 
  xdmFormat::Reader(),
  mImp( new Private ) {
}

XmfReader::~XmfReader() {
}

xdm::RefPtr< xdm::Item > 
XmfReader::readItem( const xdm::FileSystemPath& path ) {
  // Check the file exists.
  if ( !exists( path ) ) {
    XDM_THROW( xdmFormat::ReadError( "Requested path does not exist." ) );
  }
  
  // Parse the document into a tree that can be traversed.
  mImp->mDocument = xmlParseFile( path.pathString().c_str() );
  if ( !mImp->mDocument ) {
    XDM_THROW( xdmFormat::ReadError( "Unable to parse XDMF document." ) );
  }

  if ( !validate( mImp->mDocument ) ) {
    XDM_THROW( xdmFormat::ReadError( "Invalid XDMF document." ) );
  }

  // Build the tree given the root node of the validated document as input.
  impl::TreeBuilder builder( mImp->mDocument );

  xdm::RefPtr< xdm::Item > result = builder.buildTree();
  mImp->mTimestepNodes = builder.timestepNodes();
  return result;
}

bool XmfReader::update( 
  xdm::RefPtr< xdm::Item > item,
  const xdm::FileSystemPath& path,
  std::size_t timeStep )
{
  if ( mImp->mTimestepNodes.size() < timeStep ) {
    return false;
  }

  // Get the XML node corresponding to the requested time step.
  xmlNode * stepNode = mImp->mTimestepNodes[timeStep];

  UpdateXdmfTreeVisitor v( mImp->mDocument, stepNode );
  item->accept( v );
  return v.newData();
}

XDMF_NAMESPACE_END
